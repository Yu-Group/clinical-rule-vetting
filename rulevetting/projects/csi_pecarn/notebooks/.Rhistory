(N_00 + N_11) / (N_00 + N_01 + N_10 + N_11)
}
createSquareMatrix <- function() {
dim1 <- rpois(1, 3000)
dim2 <- rpois(1, 3800)
M1 <- matrix(sample(0:1, dim1 * dim2, replace = TRUE), dim1, dim2)
M2 <- matrix(sample(0:1, dim1 * dim2, replace = TRUE), dim1, dim2)
if (all(M2 == M2)) {
stop("Just try the thing again.")
} else {
list(M1, M2)
}
}
Rcpp::sourceCpp("Desktop/practice/cfuncs.cpp")
SM <- createSquareMatrix()
l1 <- SM[[1]]
l2 <- SM[[2]]
sim_r <- similarity(l1, l2)
sim_cpp <- similarityRcpp(l1, l2)
sim_r == sim_cpp
library(rbenchmark)
bm <- benchmark(
"Rcpp" = {
similarityRcpp(l1, l2)
},
"R" = {
similarity(l1, l2)
},
replications = 8,
columns = c("test",  "elapsed", "relative")
)
bm
similarity <- function(L1, L2) {
# Function to find similarity of two vectors,
#  using the MATCHING method.
# Args:
#  L1: first membership vector.
#  L2: second membership vector.
# Returns:
#  A similarity coefficient.
Nij <- function(i, j) {
sum(L1 == i & L2 == j)
}
N_00 <- Nij(0, 0)
N_01 <- Nij(0, 1)
N_10 <- Nij(1, 0)
N_11 <- Nij(1, 1)
#print(c(N_00, N_11, N_01, N_10))
(N_00 + N_11) / (N_00 + N_01 + N_10 + N_11)
}
createSquareMatrix <- function() {
dim1 <- rpois(1, 3000)
dim2 <- rpois(1, 3800)
M1 <- matrix(sample(0:1, dim1 * dim2, replace = TRUE), dim1, dim2)
M2 <- matrix(sample(0:1, dim1 * dim2, replace = TRUE), dim1, dim2)
if (all(M1 == M2)) {
stop("Just try the thing again.")
} else {
list(M1, M2)
}
}
Rcpp::sourceCpp("Desktop/practice/cfuncs.cpp")
SM <- createSquareMatrix()
l1 <- SM[[1]]
l2 <- SM[[2]]
sim_r <- similarity(l1, l2)
sim_cpp <- similarityRcpp(l1, l2)
sim_r == sim_cpp
library(rbenchmark)
bm <- benchmark(
"Rcpp" = {
similarityRcpp(l1, l2)
},
"R" = {
similarity(l1, l2)
},
replications = 8,
columns = c("test",  "elapsed", "relative")
)
bm
similarity <- function(L1, L2) {
# Function to find similarity of two vectors,
#  using the MATCHING method.
# Args:
#  L1: first membership vector.
#  L2: second membership vector.
# Returns:
#  A similarity coefficient.
Nij <- function(i, j) {
sum(L1 == i & L2 == j)
}
N_00 <- Nij(0, 0)
N_01 <- Nij(0, 1)
N_10 <- Nij(1, 0)
N_11 <- Nij(1, 1)
#print(c(N_00, N_11, N_01, N_10))
(N_00 + N_11) / (N_00 + N_01 + N_10 + N_11)
}
createSquareMatrix <- function() {
dim1 <- rpois(1, 3600)
dim2 <- rpois(1, 3800)
M1 <- matrix(sample(0:1, dim1 * dim2, replace = TRUE), dim1, dim2)
M2 <- matrix(sample(0:1, dim1 * dim2, replace = TRUE), dim1, dim2)
if (all(M1 == M2)) {
stop("Just try the thing again.")
} else {
list(M1, M2)
}
}
Rcpp::sourceCpp("Desktop/practice/cfuncs.cpp")
SM <- createSquareMatrix()
l1 <- SM[[1]]
l2 <- SM[[2]]
sim_r <- similarity(l1, l2)
sim_cpp <- similarityRcpp(l1, l2)
sim_r == sim_cpp
library(rbenchmark)
bm <- benchmark(
"Rcpp" = {
similarityRcpp(l1, l2)
},
"R" = {
similarity(l1, l2)
},
replications = 8,
columns = c("test",  "elapsed", "relative")
)
bm
similarity <- function(L1, L2) {
# Function to find similarity of two vectors,
#  using the MATCHING method.
# Args:
#  L1: first membership vector.
#  L2: second membership vector.
# Returns:
#  A similarity coefficient.
Nij <- function(i, j) {
sum(L1 == i & L2 == j)
}
N_00 <- Nij(0, 0)
N_01 <- Nij(0, 1)
N_10 <- Nij(1, 0)
N_11 <- Nij(1, 1)
#print(c(N_00, N_11, N_01, N_10))
(N_00 + N_11) / (N_00 + N_01 + N_10 + N_11)
}
createSquareMatrix <- function() {
dim1 <- rpois(1, 600)
dim2 <- rpois(1, 800)
M1 <- matrix(sample(0:1, dim1 * dim2, replace = TRUE), dim1, dim2)
M2 <- matrix(sample(0:1, dim1 * dim2, replace = TRUE), dim1, dim2)
if (all(M1 == M2)) {
stop("Just try the thing again.")
} else {
list(M1, M2)
}
}
Rcpp::sourceCpp("Desktop/practice/cfuncs.cpp")
SM <- createSquareMatrix()
l1 <- SM[[1]]
l2 <- SM[[2]]
sim_r <- similarity(l1, l2)
sim_cpp <- similarityRcpp(l1, l2)
sim_r == sim_cpp
library(rbenchmark)
bm <- benchmark(
"Rcpp" = {
similarityRcpp(l1, l2)
},
"R" = {
similarity(l1, l2)
},
replications = 8,
columns = c("test",  "elapsed", "relative")
)
bm
View(l2)
g
# check number of cores on machine
detectCores(all.tests = FALSE, logical = TRUE)
# set the number of cores to use manually
nCores <- 7
registerDoParallel(nCores)
# load in data and looFit() function
source("/Users/andyshen/Library/Mobile Documents/com~apple~CloudDocs/Desktop/Desktop - Andyâ€™s MacBook Pro/UC Berkeley/STAT 215A/Lab Sessions/week7/parallel_example/rf.R")
# look at the looFit (leave-one-out fit) function
looFit
# check number of cores on machine
detectCores(all.tests = FALSE, logical = TRUE)
# set the number of cores to use manually
nCores <- 7
registerDoParallel(nCores)
# do only first 30 for illustration
nSub <- 30
# without parallelization
ptm <- proc.time()  # start timer
outputs <- rep(NA, nSub)
for (i in 1:nSub) {
cat('Starting ', i, 'th job.\n', sep = '')
outputs[i] <- looFit(i, Y, X)
cat('Finishing ', i, 'th job.\n', sep = '')
}
proc.time() - ptm  # compute time elapsed
str(outputs)
# with parallelization
ptm <- proc.time()  # start timer
result <- foreach(i = 1:nSub) %dopar% {
cat('Starting ', i, 'th job.\n', sep = '')
output <- looFit(i, Y, X)
cat('Finishing ', i, 'th job.\n', sep = '')
output # this will become part of the out object
}
proc.time() - ptm  # compute time elapsed
str(result)
result_df <- data.frame(results = unlist(result))
str(result_df)
# with parallelization and concatenation of results
ptm <- proc.time()  # start timer
result <- foreach(i = 1:nSub, .combine = "c", .packages = c("randomForest")) %dopar% {
cat('Starting ', i, 'th job.\n', sep = '')
output <- looFit(i, Y, X)
cat('Finishing ', i, 'th job.\n', sep = '')
output # this will become part of the out object
}
proc.time() - ptm  # compute time elapsed
str(result)
View(SM)
View(bm)
View(l2)
library(foreach)
library(doParallel)
# load in data and looFit() function
source("rf.R")
getwd()
# load in data and looFit() function
source("rf.R")
# set the number of cores to use manually
nCores <- 5
registerDoParallel(nCores)
# do only first 30 for illustration
nSub <- 30
result <- foreach(i = 1:nSub) %dopar% {
cat('Starting ', i, 'th job.\n', sep = '')
output <- looFit(i, Y, X)
cat('Finishing ', i, 'th job.\n', sep = '')
output # this will become part of the out object
}
# set the number of cores to use manually
nCores <- 2
registerDoParallel(nCores)
# do only first 30 for illustration
nSub <- 30
result <- foreach(i = 1:nSub) %dopar% {
cat('Starting ', i, 'th job.\n', sep = '')
output <- looFit(i, Y, X)
cat('Finishing ', i, 'th job.\n', sep = '')
output # this will become part of the out object
}
writeLines
?writeLines
sin(x)
sin(90)
sin(pi/2)
tan(pi/2)
sin(Inf)
View(X)
nchar("Forecasting, Point Processes")
nchar("Forecasting, Point Processes, Disease Epidemics")
nchar"   "
nchar("   ")
nchar("Forecasting, Point Processes, Disease Epidemics")
system.time(chol(crossprod(matrix(runif(3000^2),nrow=3000)))) # ~1 second with blas, ~15 seconds without
name_ <- "Ron"
name[] <- "Ann"
.name <- 9
0:2*pi
rank(3:8)
rank(c(2,8, 4))
0.7 * (0.3 + 2/3 + 5/7)
90+45
15* (22.5/38)
32/38
system.time(chol(crossprod(matrix(runif(3000^2),nrow=3000)))) # ~1 second with blas, ~15 seconds without
system.time(chol(crossprod(matrix(runif(3000^2),nrow=3000)))) # ~1 second with blas, ~15 seconds without
set.seed(1)
X <- matrix(runif(30), nrow = 10, ncol = 3)
XtXinv <- solve(t(X) %*% X)
XtXinv
set.seed(1)
X <- round(matrix(runif(30, 0, 12), nrow = 10, ncol = 3), 0)
X
XtXinv <- solve(t(X) %*% X)
XtXinv
X_2 <- X[-2, ]
X_2
x2 <- X[2, ]
x2
H <- X %*% XtXinv %*% t(X)
H
y <- runif(10, 0, 8)
y
e <- H %*% y
e
betahat <- XtXinv %*% t(X) %*% y
XtXinv2 <- solve(t(X_2) %*% X_2)
XtXinv2
y2 <- y[-2]
bhat2 <- XtXinv2 %*% t(X_2) %*% y2
betahat <- XtXinv %*% t(X) %*% y
bhat2 <- XtXinv2 %*% t(X_2) %*% y2
betahat - bhat2
lhs <- c(betahat - bhat2)
lhs
rhs <- XtXinv %*% x2
rhs <- XtXinv %*% x2 * (e[2] / (1 - H[2, 2]))
rhs
c(rhs)
set.seed(1)
X <- round(matrix(runif(30, 0, 12), nrow = 10, ncol = 3), 0)
X
y <- runif(10, 0, 8)
y
XtXinv <- solve(t(X) %*% X)
XtXinv
X_2 <- X[-2, ]
X_2
y2 <- y[-2]
XtXinv2 <- solve(t(X_2) %*% X_2)
x2 <- X[2, ]
x2
H <- X %*% XtXinv %*% t(X)
H
e <- H %*% y
e
betahat <- XtXinv %*% t(X) %*% y
bhat2 <- XtXinv2 %*% t(X_2) %*% y2
lhs <- c(betahat - bhat2)
lhs
rhs <- XtXinv %*% x2 * (e[2] / (1 - H[2, 2]))
c(rhs)
H
diag(H)
X <- round(matrix(runif(30, 0, 12), nrow = 10, ncol = 3), 0)
X
y <- runif(10, 0, 8)
y
XtXinv <- solve(t(X) %*% X)
XtXinv
X_2 <- X[-2, ]
X_2
y2 <- y[-2]
y2
y
XtXinv2 <- solve(t(X_2) %*% X_2)
x2 <- X[2, ]
x2
H <- X %*% XtXinv %*% t(X)
H
e <- H %*% y
e
betahat <- XtXinv %*% t(X) %*% y
bhat2 <- XtXinv2 %*% t(X_2) %*% y2
lhs <- c(betahat - bhat2)
lhs
rhs <- XtXinv %*% x2 * (e[2] / (1 - H[2, 2]))
c(rhs)
diag(H)
XtXinv
x2
bhat2 <- XtXinv2 %*% t(X_2) %*% y
bhat2 <- XtXinv2 %*% t(X_2) %*% y2
sum(diag(H))
set.seed(1)
X <- round(matrix(runif(30, 0, 12), nrow = 10, ncol = 3), 0)
X
y <- runif(10, 0, 8)
y
XtXinv <- solve(t(X) %*% X)
XtXinv
X_2 <- X[-2, ]
X_2
y2 <- y[-2]
y2
XtXinv2 <- solve(t(X_2) %*% X_2)
x2 <- X[2, ]
x2
H <- X %*% XtXinv %*% t(X)
H
e <- H %*% y
e
XtXinv2
XtXinv + (1 / (1-H[2,2])) * XtXinv %*% x2 %*% t(x2) %*% XtXinv
rhs1 <- XtXinv + (1 / (1-H[2,2])) * XtXinv %*% x2 %*% t(x2) %*% XtXinv
all(rhs1 == XtXinv2)
all.equal(rhs1, XtXinv2)
XtXinv2
rhs1
betahat <- XtXinv %*% t(X) %*% y
bhat2 <- XtXinv2 %*% t(X_2) %*% y2
lhs <- c(betahat - bhat2)
lhs
r <- y - e
rhs <- XtXinv %*% x2 * (r[2] / (1 - H[2, 2]))
c(rhs)
set.seed(1)
X <- round(matrix(runif(30, 0, 12), nrow = 10, ncol = 3), 0)
X
y <- runif(10, 0, 8)
y
XtXinv <- solve(t(X) %*% X)
XtXinv
X_2 <- X[-2, ]
X_2
y2 <- y[-2]
y2
XtXinv2 <- solve(t(X_2) %*% X_2)
x2 <- X[2, ]
x2
H <- X %*% XtXinv %*% t(X)
H
e <- H %*% y
e
r <- y - e
rhs1 <- XtXinv + (1 / (1-H[2,2])) * XtXinv %*% x2 %*% t(x2) %*% XtXinv
betahat <- XtXinv %*% t(X) %*% y
bhat2 <- XtXinv2 %*% t(X_2) %*% y2
lhs <- c(betahat - bhat2)
lhs
rhs <- XtXinv %*% x2 * (r[2] / (1 - H[2, 2]))
c(rhs)
all.equal(lhs, rhs)
lhs
rhs <- XtXinv %*% x2 * (r[2] / (1 - H[2, 2]))
c(rhs)
set.seed(1)
X <- round(matrix(runif(30, 0, 12), nrow = 10, ncol = 3), 0)
X
y <- runif(10, 0, 8)
y
XtXinv <- solve(t(X) %*% X)
XtXinv
X_2 <- X[-2, ]
X_2
y2 <- y[-2]
y2
XtXinv2 <- solve(t(X_2) %*% X_2)
x2 <- X[2, ]
x2
H <- X %*% XtXinv %*% t(X)
H
yhat <- H %*% y
ythat
r <- y - yhat
rhs1 <- XtXinv + (1 / (1-H[2,2])) * XtXinv %*% x2 %*% t(x2) %*% XtXinv
betahat <- XtXinv %*% t(X) %*% y
bhat2 <- XtXinv2 %*% t(X_2) %*% y2
lhs <- c(betahat - bhat2)
lhs
rhs <- XtXinv %*% x2 * (r[2] / (1 - H[2, 2]))
c(rhs)
all.equal(lhs, rhs)
all.equal(lhs, c(rhs))
h22 <- H[2,2]
XtXinv %*% x2 * (y[2] - (1 / (1-h22)) * (t(x2) %*% XtXinv %**% X_2 %*% y2) )
XtXinv %*% x2 * (y[2] - (1 / (1-h22)) * (t(x2) %*% XtXinv %*% X_2 %*% y2) )
t(x2)
t(x2) %*% XtXinv
t(x2) %*% XtXinv %*% X_2
X_2
XtXinv %*% x2 * (y[2] - (1 / (1-h22)) * (t(x2) %*% XtXinv %*% t(X_2) %*% y2) )
t(x2) %*% XtXinv %*% t(X_2) %*% y2
XtXinv %*% x2 * (y[2] - (1 / (1-h22)) * as.numeric(t(x2) %*% XtXinv %*% t(X_2) %*% y2) )
lhs
t(x2) %*% XtXinv %*% X_2 %*%* y2
t(x2) %*% XtXinv %*% X_2 %*% y2
t(x2) %*% XtXinv %*% t(X_2) %*% y2
sum(H[2,])
yhat[2]
yhat[2] - H[2,2]*y[2]
t(x2) %*% XtXinv %*% t(X_2) %*% y2
yhat[2] - H[2,2]*y[2]
sum(H[2, ] * y)
sum(H[2, ] * y) - y[2]*H[2,2]
XtXinv %*% x2 * (y[2] - (1 / (1-h22)) * as.numeric(t(x2) %*% XtXinv %*% t(X_2) %*% y2))
t(x2) %*% XtXinv %*% t(X_2) %*% y2
sum(H[2, ] * y) - y[2]*H[2,2]
yhat[2] - H[2,2]*y[2]
sum(H[2, ] * y) - y[2]*H[2,2]
yhat
x2
x2 %*% XtXinv %*% t(x2)
x2 %*% XtXinv
x2 %*% XtXinv %*% t(x2)
x2 %*% XtXinv %*% t(x2)
t(x2)
x2 %*% XtXinv %*% (x2)
yhat[2]
H %*% y
x2 %*% XtXinv %*% (x2) * y[2]
x2 %*% XtXinv %*% (x2) %*% y
x2 %*% XtXinv %*% (x2)
H[2,2]
H
H[2,] * y
sum(H[2,] * y)
View(yhat)
x = 8;
reticulate::repl_python()
import numpy as np;
reticulate::repl_python()
yes
reticulate::repl_python()
